# frozen_string_literal: true

require 'fileutils'
require 'yaml'

module JekyllNotionCMS
  # Jekyll Generator that fetches data from Notion databases
  class Generator < Jekyll::Generator
    safe true
    priority :highest

    def generate(site)
      @site = site
      @config = site.config['notion'] || {}
      @collections_config = @config['collections'] || {}

      unless @config['enabled'] != false
        Jekyll.logger.info 'NotionCMS:', 'Plugin disabled in configuration'
        return
      end

      unless ENV['NOTION_TOKEN']
        Jekyll.logger.info 'NotionCMS:', 'No NOTION_TOKEN found, using collections fallback'
        use_all_collections_fallback
        return
      end

      Jekyll.logger.info 'NotionCMS:', 'Fetching data from Notion API...'

      begin
        @client = NotionClient.new(ENV['NOTION_TOKEN'])

        @collections_config.each do |collection_name, collection_config|
          fetch_collection_data(collection_name, collection_config)
        end

        Jekyll.logger.info 'NotionCMS:', 'All data fetched successfully'
      rescue StandardError => e
        Jekyll.logger.error 'NotionCMS:', "Error fetching data: #{e.message}"
        Jekyll.logger.warn 'NotionCMS:', 'Falling back to collections'
        use_all_collections_fallback
      end
    end

    private

    # Fetch data for a single collection
    def fetch_collection_data(collection_name, config)
      env_var = config['database_env']
      data_file = config['data_file']

      database_id = ENV[env_var]
      if database_id.nil? || database_id.empty? || database_id.start_with?('example_')
        Jekyll.logger.info 'NotionCMS:', "No #{env_var} found, using fallback for #{collection_name}"
        use_collection_fallback(collection_name, config)
        return
      end

      begin
        notion_data = @client.query_database(database_id)
        organized_data = DataOrganizers.organize(notion_data, config)

        if DataOrganizers.data_present?(organized_data)
          data_key = data_file.sub('.yml', '').sub('.yaml', '')
          @site.data[data_key] = organized_data
          create_data_file(organized_data, data_file, collection_name)

          count = organized_data.is_a?(Hash) ? organized_data.size : organized_data.length
          Jekyll.logger.info 'NotionCMS:', "#{collection_name} fetched (#{count} items)"
        else
          Jekyll.logger.warn 'NotionCMS:', "No data found for #{collection_name}, using fallback"
          use_collection_fallback(collection_name, config)
        end
      rescue StandardError => e
        Jekyll.logger.error 'NotionCMS:', "Error fetching #{collection_name}: #{e.message}"
        use_collection_fallback(collection_name, config)
      end
    end

    # Create a YAML data file
    def create_data_file(data, file_name, collection_name)
      data_dir = File.join(@site.source, '_data')
      FileUtils.mkdir_p(data_dir) unless Dir.exist?(data_dir)

      data_file = File.join(data_dir, file_name)
      new_content = data.to_yaml

      # Skip if content unchanged
      if File.exist?(data_file)
        existing_content = File.read(data_file)
        yaml_start = existing_content.index("---\n")
        if yaml_start
          existing_yaml = existing_content[yaml_start..-1]
          if existing_yaml.strip == new_content.strip
            Jekyll.logger.info 'NotionCMS:', "#{collection_name} data unchanged, skipping"
            return
          end
        end
      end

      File.open(data_file, 'w') do |file|
        file.write("# #{collection_name.capitalize} data imported from Notion\n")
        file.write("# Auto-generated by jekyll-notion-cms - Do not edit manually\n")
        file.write("# Last updated: #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        file.write(new_content)
      end

      Jekyll.logger.info 'NotionCMS:', "#{collection_name} written to _data/#{file_name}"
    end

    # Use fallback for all collections
    def use_all_collections_fallback
      @collections_config.each do |collection_name, config|
        use_collection_fallback(collection_name, config)
      end
    end

    # Use Jekyll collections as fallback
    def use_collection_fallback(collection_name, config)
      Jekyll.logger.info 'NotionCMS:', "Using fallback for #{collection_name}"

      data_file = config['data_file']
      data_key = data_file.sub('.yml', '').sub('.yaml', '')
      properties_config = config['properties'] || []

      # Convert Jekyll collection to Notion-like format
      mock_data = { 'results' => [] }

      if @site.collections[collection_name]
        @site.collections[collection_name].docs.each_with_index do |doc, index|
          mock_data['results'] << {
            'id' => "collection_#{index}",
            'properties' => convert_doc_to_properties(doc.data, properties_config),
            'created_time' => doc.data['date']&.to_s,
            'last_edited_time' => doc.data['last_modified']&.to_s
          }
        end
      end

      organized_data = DataOrganizers.organize(mock_data, config)
      @site.data[data_key] = organized_data
      create_data_file(organized_data, data_file, collection_name)

      count = organized_data.is_a?(Hash) ? organized_data.size : organized_data.length
      Jekyll.logger.info 'NotionCMS:', "#{collection_name} fallback applied (#{count} items)"
    end

    # Convert Jekyll document data to Notion-like properties
    def convert_doc_to_properties(data, properties_config)
      properties = {}

      properties_config.each do |prop_config|
        prop_name = prop_config['name']
        prop_type = prop_config['type']
        prop_key = prop_config['key'] || PropertyExtractors.normalize_key(prop_name)

        value = data[prop_key] || data[prop_name.downcase] || data[prop_name]
        next if value.nil?

        properties[prop_name] = convert_value_to_notion_property(value, prop_type)
      end

      properties
    end

    # Convert a value to Notion property format
    def convert_value_to_notion_property(value, prop_type)
      case prop_type
      when 'title'
        { 'type' => 'title', 'title' => [{ 'plain_text' => value.to_s }] }
      when 'rich_text'
        { 'type' => 'rich_text', 'rich_text' => [{ 'plain_text' => value.to_s }] }
      when 'number'
        { 'type' => 'number', 'number' => value.to_i }
      when 'checkbox'
        { 'type' => 'checkbox', 'checkbox' => !!value }
      when 'date'
        { 'type' => 'date', 'date' => { 'start' => value.to_s } }
      when 'select'
        { 'type' => 'select', 'select' => { 'name' => value.to_s } }
      when 'multi_select'
        items = value.is_a?(Array) ? value : [value]
        { 'type' => 'multi_select', 'multi_select' => items.map { |v| { 'name' => v.to_s } } }
      when 'url'
        { 'type' => 'url', 'url' => value.to_s }
      else
        { 'type' => 'rich_text', 'rich_text' => [{ 'plain_text' => value.to_s }] }
      end
    end
  end
end
